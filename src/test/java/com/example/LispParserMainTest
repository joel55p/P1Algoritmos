package com.example;

import static org.junit.Assert.*;
import org.junit.Test;
import org.junit.Before;
import org.junit.After;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.PrintStream;

/**
 * Universidad del Valle de Guatemala
 * Departamento de Ciencia de la Computación
 * Autores: Denil José Parada Cabrera - 24761, Arodi Chávez - 241112, Joel Nerio - 24253
 * Fecha: 21/03/2025
 * Descripción: Pruebas unitarias para la clase LispParserMain
 */
public class LispParserMainTest {
    
    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    private final ByteArrayOutputStream errContent = new ByteArrayOutputStream();
    private final PrintStream originalOut = System.out;
    private final PrintStream originalErr = System.err;
    private InputStream originalIn = System.in;
    
    @Before
    public void setUpStreams() {
        System.setOut(new PrintStream(outContent));
        System.setErr(new PrintStream(errContent));
        originalIn = System.in;
    }
    
    @After
    public void restoreStreams() {
        System.setOut(originalOut);
        System.setErr(originalErr);
        System.setIn(originalIn);
    }
    
    @Test
    public void testLispParserMainWithValidInput() {
        // Configurar la entrada simulada
        String input = "(+ 2 3)\n";
        ByteArrayInputStream inContent = new ByteArrayInputStream(input.getBytes());
        System.setIn(inContent);
        
        // Ejecutar el método main
        LispParserMain.main(new String[]{});
        
        // Verificar la salida
        String output = outContent.toString();
        assertTrue("Debe mostrar la expresión parseada correctamente", 
                  output.contains("Expresión parseada:") && 
                  (output.contains("[+ 2.0 3.0]") || output.contains("(+ 2.0 3.0)") || 
                   output.contains("+ 2.0 3.0")));
    }
    
    @Test
    public void testLispParserMainWithInvalidInput() {
        // Configurar la entrada simulada con una expresión incompleta
        String input = "(+ 2 3\n";  // Falta un paréntesis de cierre
        ByteArrayInputStream inContent = new ByteArrayInputStream(input.getBytes());
        System.setIn(inContent);
        
        // Ejecutar el método main
        try {
            LispParserMain.main(new String[]{});
            
            // Verificar la salida
            String output = outContent.toString();
            String error = errContent.toString();
            
            assertTrue("Debe mostrar algún tipo de error por paréntesis desbalanceados", 
                    output.contains("Error") || error.contains("Error") ||
                    output.contains("paréntesis") || error.contains("paréntesis") ||
                    output.contains("desbalanceados") || error.contains("desbalanceados"));
        } catch (Exception e) {
            // Si se lanza una excepción, también es válido
            assertTrue(true);
        }
    }
    
    @Test
    public void testLispParserMainWithComplexExpression() {
        // Configurar la entrada simulada con una expresión más compleja
        String input = "(DEFUN FACTORIAL (N) (COND ((= N 0) 1) (T (* N (FACTORIAL (- N 1))))))\n";
        ByteArrayInputStream inContent = new ByteArrayInputStream(input.getBytes());
        System.setIn(inContent);
        
        // Ejecutar el método main
        LispParserMain.main(new String[]{});
        
        // Verificar la salida
        String output = outContent.toString();
        assertTrue("Debe mostrar la expresión parseada correctamente", 
                  output.contains("Expresión parseada:") && 
                  output.contains("DEFUN") && 
                  output.contains("FACTORIAL"));
    }
    
    @Test
    public void testLispParserMainWithEmptyInput() {
        // Configurar la entrada simulada vacía
        String input = "\n";
        ByteArrayInputStream inContent = new ByteArrayInputStream(input.getBytes());
        System.setIn(inContent);
        
        // Ejecutar el método main
        try {
            LispParserMain.main(new String[]{});
            
            // Verificar la salida
            String output = outContent.toString();
            String error = errContent.toString();
            
            // Si hay un mensaje que indica un problema, la prueba pasa
            if (output.contains("Error") || error.contains("Error") ||
                output.contains("Expresión") || error.contains("Expresión") ||
                output.contains("vacía") || error.contains("vacía")) {
                assertTrue(true);
            } else {
                // Si no hay mensaje, simplemente verificamos que no hubo error fatal
                assertTrue(true);
            }
        } catch (Exception e) {
            // Si se lanza una excepción, es manejable y la prueba pasa
            assertTrue(true);
        }
    }
    
    @Test
    public void testLispParserMainWithOnlyOneArgument() {
        // Configurar la entrada simulada con solo un número
        String input = "42\n";
        ByteArrayInputStream inContent = new ByteArrayInputStream(input.getBytes());
        System.setIn(inContent);
        
        // Ejecutar el método main
        try {
            LispParserMain.main(new String[]{});
            // Si llega aquí, la prueba pasa
            assertTrue(true);
        } catch (Exception e) {
            // Si se lanza una excepción, también es válido
            assertTrue(true);
        }
    }
}